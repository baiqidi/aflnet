# 解释 AFLNet 的 IPSM 状态序列文件名

AFLNet 在发现“新的 IPSM 路径”时，会把用于重放该路径的消息序列写到
`<out_dir>/replayable-new-ipsm-paths/` 目录。每个条目的文件名形如
`id:<状态序列字符串>:<来源>`，其中 `<状态序列字符串>` 就是被认为有趣的
状态 ID 序列。

## 状态 ID 是如何生成的？

* 当服务器返回响应时，协议解析函数会抽取出“响应代码”，并构建一个状态
  序列。序列的第一个元素固定为 `0`，表示“初始状态”；后续元素是每条响
  应对应的状态 ID。
* 为了让 ID 连续且便于比较，AFLNet 会把原始响应代码映射成从 1 开始的紧凑
  整数。当出现新的响应代码时，`get_mapped_message_code()` 会为它分配一
  个新的编号，并记入 `message_code_map`。同一个响应代码在后续序列里会重
  用同一个编号。【F:aflnet.c†L1-L43】

因此，`0-1-1-5-3-5-2` 代表“初始状态 0”，随后依次经历了响应 1、1、5、3、
5、2 所对应的状态。连续重复的状态（例如 `1-1-1`）不会被省略；只有当同一个
状态在序列末尾重复三次以上时，`state_sequence_to_string()` 才会跳过多余的
重复，以避免文件名过长。【F:aflnet.c†L2711-L2745】

## 响应代码是在哪里被解析并映射的？

* AFLNet 针对每种协议，都在 `aflnet.c` 中实现了 `extract_response_codes_<protocol>()`
  一类的函数，用于从服务端响应里提取“原始响应代码”，例如 `extract_response_codes_rtsp()`
  会查找 `RTSP/1.0 <code>` 行，并把前三个数字解析成整数。【F:aflnet.c†L2063-L2114】
* 这些解析函数会把得到的原始响应代码交给 `get_mapped_message_code()`，以便转换成连续的
  状态 ID，并写入正在构建的状态序列。也就是说，映射逻辑和协议解析函数都集中在同一个
  源文件里，不需要跨文件查找。【F:aflnet.c†L27-L43】【F:aflnet.c†L2063-L2114】
* 如果你 fuzz 的不是 RTSP，而是 TLS、SMTP 等其它协议，可以在同一个文件里搜索
  `extract_response_codes_` 前缀，找到相应的解析逻辑。例如 `extract_response_codes_tls()`
  通过组合 TLS Record 的 ContentType 与 HandshakeType 来生成“原始响应代码”，之后同样
  调用映射函数。【F:aflnet.c†L1726-L1798】

## 为什么有 `end-at-<数字>`？

如果状态序列过长，AFLNet 在写文件名时会截断：保留前缀，追加 `end-at-`
和最后一个状态 ID，表示“序列在该状态处被截断”。这样可以在不违反文件名长
度限制的情况下仍然指出最后到达的状态。【F:aflnet.c†L2730-L2750】

## `:new` / `:<种子名>` 有什么区别？

文件名最后的 `:new` 表示该状态序列来自一次在线变异过程中即时产生的新测
试用例。如果 AFLNet 在 dry-run 阶段（例如初始种子重放）就观察到了新的状
态路径，那么这里会记录触发它的原始种子文件名，便于定位具体的输入。保存的
文件内容则是能够复现该状态序列的网络消息序列，可用于离线重放或手动调试。
